<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document Manager</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
  />
  <style>
    :root {
      --black: #121212;
      --dark-green: #1a472a;
      --green: #2e7d32;
      --light-green: #4caf50;
      --yellow: #ffd700;
      --light-yellow: #ffeb3b;
      --gray: #f5f5f5;
      --white: #ffffff;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background-color: var(--gray);
      color: var(--black);
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: linear-gradient(135deg, var(--dark-green), var(--green));
      color: var(--white);
      padding: 20px 0;
      margin-bottom: 30px;
      border-radius: 10px;
      box-shadow: var(--shadow);
    }

    header .container {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 24px;
      font-weight: 700;
    }

    .logo i {
      color: var(--yellow);
      font-size: 28px;
    }

    .card {
      background-color: var(--white);
      border-radius: 10px;
      box-shadow: var(--shadow);
      padding: 25px;
      margin-bottom: 25px;
      transition: var(--transition);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
    }

    h1,
    h2 {
      color: var(--dark-green);
      margin-bottom: 20px;
      position: relative;
      display: inline-block;
    }

    h1::after,
    h2::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: -5px;
      width: 40px;
      height: 3px;
      background-color: var(--yellow);
      transition: var(--transition);
    }

    h1:hover::after,
    h2:hover::after {
      width: 100%;
    }

    .flex-container {
      display: flex;
      gap: 25px;
      flex-wrap: wrap;
    }

    .flex-item {
      flex: 1;
      min-width: 300px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--dark-green);
    }

    input,
    button,
    select {
      width: 100%;
      padding: 12px 15px;
      border-radius: 6px;
      font-family: 'Poppins', sans-serif;
      font-size: 14px;
      transition: var(--transition);
    }

    input,
    select {
      border: 1px solid #ddd;
      background-color: var(--gray);
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--green);
      box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.2);
    }

    .btn {
      background-color: var(--green);
      color: var(--white);
      border: none;
      cursor: pointer;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:hover {
      background-color: var(--dark-green);
      transform: translateY(-2px);
    }

    .btn-accent {
      background-color: var(--yellow);
      color: var(--black);
    }

    .btn-accent:hover {
      background-color: var(--light-yellow);
    }

    .file-upload {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 30px;
      border: 2px dashed var(--green);
      border-radius: 10px;
      background-color: rgba(76, 175, 80, 0.05);
      transition: var(--transition);
      cursor: pointer;
      margin-bottom: 15px;
    }

    .file-upload:hover {
      background-color: rgba(76, 175, 80, 0.1);
      border-color: var(--dark-green);
    }

    .file-upload i {
      font-size: 48px;
      color: var(--green);
      margin-bottom: 15px;
    }

    .file-upload input {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      opacity: 0;
      cursor: pointer;
    }

    .file-info {
      text-align: center;
    }

    .file-info h3 {
      font-weight: 500;
      margin-bottom: 5px;
    }

    .file-info p {
      color: #666;
      font-size: 14px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    th,
    td {
      padding: 15px;
      text-align: left;
    }

    th {
      background-color: var(--dark-green);
      color: var(--white);
      font-weight: 500;
    }

    tr {
      background-color: var(--white);
      transition: var(--transition);
    }

    tr:nth-child(even) {
      background-color: rgba(76, 175, 80, 0.05);
    }

    tr:hover {
      background-color: rgba(76, 175, 80, 0.1);
    }

    .actions {
      display: flex;
      gap: 10px;
    }

    .btn-update {
      background-color: var(--green);
    }

    .btn-delete {
      background-color: #f44336;
    }

    .btn-view {
      background-color: var(--yellow);
      color: var(--black);
    }

    .empty-state {
      text-align: center;
      padding: 40px 0;
      color: #666;
    }

    .empty-state i {
      font-size: 60px;
      color: #ddd;
      margin-bottom: 20px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }

    .badge i {
      font-size: 10px;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: var(--dark-green);
      color: white;
      padding: 15px 25px;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 10px;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast i {
      font-size: 20px;
    }

    .toast.success {
      background-color: var(--green);
    }

    .toast.error {
      background-color: #f44336;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    @media (max-width: 768px) {
      .flex-container {
        flex-direction: column;
      }

      .actions {
        flex-direction: column;
      }

      table {
        display: block;
        overflow-x: auto;
      }
    }

    .sortable {
      cursor: pointer;
      user-select: none;
    }
    .sortable:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    .sortable i {
      margin-left: 5px;
    }

    #pagination-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 5px;
      margin-top: 20px;
    }

    #pagination-controls .btn {
      padding: 5px 10px;
      border-radius: 5px;
      background-color: var(--light-green);
      color: var(--white);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #pagination-controls .btn:hover {
      background-color: var(--dark-green);
    }

    #pagination-controls .btn:disabled {
      background-color: var(--gray);
      cursor: not-allowed;
    }

    .collection-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    /* Searchable Dropdown Styles */
    .searchable-dropdown {
      position: relative;
      width: 100%;
    }

    .dropdown-input {
      width: 100%;
      padding: 12px 40px 12px 15px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background-color: var(--gray);
      font-family: 'Poppins', sans-serif;
      font-size: 14px;
      cursor: pointer;
      transition: var(--transition);
    }

    .dropdown-input:focus {
      outline: none;
      border-color: var(--green);
      box-shadow: 0 0 0 3px rgba(46, 125, 50, 0.2);
    }

    .dropdown-arrow {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: var(--green);
      transition: var(--transition);
    }

    .dropdown-arrow.open {
      transform: translateY(-50%) rotate(180deg);
    }

    .dropdown-options {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 6px 6px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .dropdown-options.show {
      display: block;
    }

    .dropdown-option {
      padding: 12px 15px;
      cursor: pointer;
      transition: var(--transition);
      border-bottom: 1px solid #f0f0f0;
    }

    .dropdown-option:hover {
      background-color: rgba(76, 175, 80, 0.1);
    }

    .dropdown-option:last-child {
      border-bottom: none;
    }

    .dropdown-option.selected {
      background-color: var(--green);
      color: white;
    }

    .dropdown-option.hidden {
      display: none;
    }

    .no-results {
      padding: 12px 15px;
      color: #666;
      font-style: italic;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <div class="logo">
        <i class="fas fa-file-alt"></i>
        <span>Document Manager</span>
      </div>
      <div id="user-info" style="display: none;">
        <span id="username"></span>
        <button
          id="logout-btn"
          class="btn btn-accent"
          style="width: auto; padding: 8px 15px; margin-left: 10px;"
        >
          <i class="fas fa-sign-out-alt"></i> Logout
        </button>
      </div>
    </div>
  </header>

  <div class="container">
    <!-- Login/Register Section -->
    <div id="auth" class="animate-fade-in">
      <div class="flex-container">
        <div class="flex-item">
          <div class="card">
            <h2><i class="fas fa-sign-in-alt"></i> Login</h2>
            <form id="login-form">
              <div class="form-group">
                <label for="login-username">Username</label>
                <input
                  type="text"
                  id="login-username"
                  name="username"
                  placeholder="Enter your username"
                  required
                />
              </div>
              <div class="form-group">
                <label for="login-password">Password</label>
                <input
                  type="password"
                  id="login-password"
                  name="password"
                  placeholder="Enter your password"
                  required
                />
              </div>
              <button type="submit" class="btn">
                <i class="fas fa-lock-open"></i> Login
              </button>
            </form>
          </div>
        </div>
        <div class="flex-item">
          <div class="card">
            <h2><i class="fas fa-user-plus"></i> Register</h2>
            <form id="register-form">
              <div class="form-group">
                <label for="register-username">Username</label>
                <input
                  type="text"
                  id="register-username"
                  name="username"
                  placeholder="Choose a username"
                  required
                />
              </div>
              <div class="form-group">
                <label for="register-password">Password</label>
                <input
                  type="password"
                  id="register-password"
                  name="password"
                  placeholder="Choose a password"
                  required
                />
              </div>
              <button type="submit" class="btn btn-accent">
                <i class="fas fa-user-check"></i> Register
              </button>
            </form>
          </div>
        </div>
      </div>
    </div>

    <!-- Document Management Section -->
    <div id="pdf-management" style="display: none;" class="animate-fade-in">
      <div class="card">
        <h2><i class="fas fa-cloud-upload-alt"></i> Upload Documents</h2>
        <form id="upload-form">
          <div class="file-upload">
            <i class="fas fa-file-alt pulse"></i>
            <div class="file-info">
              <h3>Drag & Drop your documents here</h3>
              <p>or click to browse files</p>
              <p><small>Supported formats: PDF, Excel (.xlsx, .xls)</small></p>
            </div>
            <input type="file" name="files" multiple accept=".pdf,.xlsx,.xls" required />
          </div>
          <div class="form-group">
            <label for="description">Description</label>
            <input
              type="text"
              id="description"
              name="description"
              placeholder="Add a description (applies to all files)"
            />
          </div>
          <div class="form-group">
            <label for="collection">Collection (optional)</label>
            <div class="searchable-dropdown" id="collection-dropdown">
              <input 
                type="text" 
                id="collection-input" 
                class="dropdown-input" 
                placeholder="Search or select a collection..." 
                autocomplete="off"
                readonly
              />
              <i class="fas fa-chevron-down dropdown-arrow"></i>
              <div class="dropdown-options" id="collection-options">
                <div class="dropdown-option" data-value="">Default Collection</div>
              </div>
            </div>
            <input type="hidden" id="collection" name="collection" value="" />
          </div>
          <div class="form-group">
            <label for="collection-filter">Filter by Collection</label>
            <div class="searchable-dropdown" id="collection-filter-dropdown">
              <input 
                type="text" 
                id="collection-filter-input" 
                class="dropdown-input" 
                placeholder="Search or select a collection to filter..." 
                autocomplete="off"
                readonly
              />
              <i class="fas fa-chevron-down dropdown-arrow"></i>
              <div class="dropdown-options" id="collection-filter-options">
                <div class="dropdown-option" data-value="">All Collections</div>
                <div class="dropdown-option" data-value="default">Default Collection</div>
              </div>
            </div>
            <input type="hidden" id="collection-filter" value="" />
          </div>
          <button type="submit" class="btn">
            <i class="fas fa-upload"></i> Upload Documents
          </button>
        </form>
      </div>

      <!-- Bulk Actions Section -->
      <div class="card">
        <h2><i class="fas fa-tasks"></i> Bulk Actions</h2>
        <div class="form-group" style="display: flex; gap: 10px;">
          <button onclick="bulkDeletePDFs()" class="btn btn-delete" style="flex:1;">
            <i class="fas fa-trash"></i> Delete Selected
          </button>
          <button onclick="bulkUpdatePDFsDescription()" class="btn btn-update" style="flex:1;">
            <i class="fas fa-edit"></i> Update Description for Selected
          </button>
        </div>
      </div>

      <div class="card">
        <h2><i class="fas fa-file-alt"></i> Your Documents</h2>
        <div class="form-group">
          <input
            type="text"
            id="pdf-search"
            placeholder="Search documents by name or description..."
            style="margin-bottom: 15px;"
          />
        </div>
        <div id="pdf-table-container">
          <table>
            <thead>
              <tr>
                <th>
                  <input type="checkbox" id="select-all" onchange="toggleSelectAll(this)" />
                </th>
                <th>Filename</th>
                <th>Description</th>
                <th class="sortable" onclick="sortPDFs('upload_date')">
                  Upload Date <i class="fas fa-sort"></i>
                </th>
                <th>Pages/Sheets</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="pdf-list"></tbody>
          </table>
        </div>
        <div id="empty-state" class="empty-state" style="display: none;">
          <i class="fas fa-folder-open"></i>
          <h3>No documents found</h3>
          <p>Upload your first document to get started</p>
        </div>
      </div>
    </div>

    <!-- Collection Management Section -->
    <div class="card">
      <h2><i class="fas fa-layer-group"></i> Collections</h2>
      <div class="form-group">
        <label for="collection-name">New Collection Name</label>
        <input type="text" id="collection-name" placeholder="Enter collection name" />
      </div>
      <div class="form-group">
        <label for="collection-description">Description (optional)</label>
        <input
          type="text"
          id="collection-description"
          placeholder="Enter collection description"
        />
      </div>
      <button onclick="createCollection()" class="btn">
        <i class="fas fa-plus"></i> Create Collection
      </button>

      <div id="collections-list" style="margin-top: 20px;">
        <!-- Collections will be listed here -->
      </div>
    </div>
  </div>

  <div id="toast" class="toast">
    <i class="fas fa-check-circle"></i>
    <span id="toast-message"></span>
  </div>

  <script>
    let token = localStorage.getItem("token");
    let currentUsername = localStorage.getItem("username");
    let currentPage = 1;
    const itemsPerPage = 20;
    let currentCollection = "";
    let collections = []; // To store fetched collections for later use

    // Searchable Dropdown Class
    class SearchableDropdown {
      constructor(dropdownId, inputId, optionsId, hiddenInputId, onChangeCallback = null) {
        this.dropdown = document.getElementById(dropdownId);
        this.input = document.getElementById(inputId);
        this.options = document.getElementById(optionsId);
        this.hiddenInput = document.getElementById(hiddenInputId);
        this.arrow = this.dropdown.querySelector('.dropdown-arrow');
        this.onChangeCallback = onChangeCallback;
        this.isOpen = false;
        this.selectedValue = '';
        this.selectedText = '';
        
        this.init();
      }

      init() {
        // Toggle dropdown on input click
        this.input.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggle();
        });

        // Handle search input
        this.input.addEventListener('input', () => {
          this.filterOptions();
        });

        // Handle option selection
        this.options.addEventListener('click', (e) => {
          if (e.target.classList.contains('dropdown-option')) {
            this.selectOption(e.target);
          }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!this.dropdown.contains(e.target)) {
            this.close();
          }
        });

        // Handle keyboard navigation
        this.input.addEventListener('keydown', (e) => {
          this.handleKeyboard(e);
        });
      }

      toggle() {
        if (this.isOpen) {
          this.close();
        } else {
          this.open();
        }
      }

      open() {
        this.isOpen = true;
        this.options.classList.add('show');
        this.arrow.classList.add('open');
        this.input.removeAttribute('readonly');
        this.input.focus();
        
        // Reset search when opening
        if (this.input.value === this.selectedText) {
          this.input.value = '';
        }
        this.filterOptions();
      }

      close() {
        this.isOpen = false;
        this.options.classList.remove('show');
        this.arrow.classList.remove('open');
        this.input.setAttribute('readonly', 'true');
        
        // Restore selected text if nothing was selected
        if (this.selectedText) {
          this.input.value = this.selectedText;
        } else {
          this.input.value = '';
        }
      }

      selectOption(optionElement) {
        const value = optionElement.getAttribute('data-value');
        const text = optionElement.textContent;
        
        // Update selected values
        this.selectedValue = value;
        this.selectedText = text;
        this.input.value = text;
        this.hiddenInput.value = value;
        
        // Update visual selection
        this.options.querySelectorAll('.dropdown-option').forEach(opt => {
          opt.classList.remove('selected');
        });
        optionElement.classList.add('selected');
        
        this.close();
        
        // Call callback if provided
        if (this.onChangeCallback) {
          this.onChangeCallback(value, text);
        }
      }

      filterOptions() {
        const searchTerm = this.input.value.toLowerCase();
        const optionElements = this.options.querySelectorAll('.dropdown-option');
        let hasVisibleOptions = false;
        
        optionElements.forEach(option => {
          const text = option.textContent.toLowerCase();
          if (text.includes(searchTerm)) {
            option.classList.remove('hidden');
            hasVisibleOptions = true;
          } else {
            option.classList.add('hidden');
          }
        });
        
        // Show/hide no results message
        let noResultsMsg = this.options.querySelector('.no-results');
        if (!hasVisibleOptions && searchTerm) {
          if (!noResultsMsg) {
            noResultsMsg = document.createElement('div');
            noResultsMsg.className = 'no-results';
            noResultsMsg.textContent = 'No collections found';
            this.options.appendChild(noResultsMsg);
          }
          noResultsMsg.style.display = 'block';
        } else if (noResultsMsg) {
          noResultsMsg.style.display = 'none';
        }
      }

      handleKeyboard(e) {
        if (!this.isOpen) return;
        
        const visibleOptions = Array.from(this.options.querySelectorAll('.dropdown-option:not(.hidden)'));
        const currentSelected = this.options.querySelector('.dropdown-option.selected');
        let currentIndex = visibleOptions.indexOf(currentSelected);
        
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            currentIndex = Math.min(currentIndex + 1, visibleOptions.length - 1);
            if (visibleOptions[currentIndex]) {
              this.selectOption(visibleOptions[currentIndex]);
            }
            break;
          case 'ArrowUp':
            e.preventDefault();
            currentIndex = Math.max(currentIndex - 1, 0);
            if (visibleOptions[currentIndex]) {
              this.selectOption(visibleOptions[currentIndex]);
            }
            break;
          case 'Enter':
            e.preventDefault();
            if (visibleOptions[currentIndex]) {
              this.selectOption(visibleOptions[currentIndex]);
            }
            break;
          case 'Escape':
            e.preventDefault();
            this.close();
            break;
        }
      }

      updateOptions(optionsData) {
        // Clear existing options except the first one (default)
        const defaultOption = this.options.querySelector('.dropdown-option[data-value=""]');
        this.options.innerHTML = '';
        
        if (defaultOption) {
          this.options.appendChild(defaultOption);
        }
        
        // Add new options
        optionsData.forEach(option => {
          const optionElement = document.createElement('div');
          optionElement.className = 'dropdown-option';
          optionElement.setAttribute('data-value', option.value);
          optionElement.textContent = option.text;
          this.options.appendChild(optionElement);
        });
      }

      setValue(value, text) {
        this.selectedValue = value;
        this.selectedText = text;
        this.input.value = text;
        this.hiddenInput.value = value;
        
        // Update visual selection
        this.options.querySelectorAll('.dropdown-option').forEach(opt => {
          opt.classList.remove('selected');
          if (opt.getAttribute('data-value') === value) {
            opt.classList.add('selected');
          }
        });
      }
    }

    // Initialize searchable dropdowns
    let collectionDropdown, collectionFilterDropdown;

    // Initialize dropdowns after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Collection dropdown for upload
      collectionDropdown = new SearchableDropdown(
        'collection-dropdown',
        'collection-input', 
        'collection-options',
        'collection'
      );

      // Collection filter dropdown
      collectionFilterDropdown = new SearchableDropdown(
        'collection-filter-dropdown',
        'collection-filter-input',
        'collection-filter-options', 
        'collection-filter',
        (value, text) => {
          // Callback for filter change
          currentCollection = value;
          currentPage = 1;
          fetchPDFs();
        }
      );

      // Set default values
      collectionDropdown.setValue('', 'Default Collection');
      collectionFilterDropdown.setValue('', 'All Collections');
    });

    // Helper function to get file icon based on file type
    function getFileIcon(filename, fileType) {
      const extension = filename.split('.').pop().toLowerCase();
      const type = fileType || extension;
      
      switch (type) {
        case 'pdf':
          return '<i class="fas fa-file-pdf" style="color: #d32f2f;"></i>';
        case 'xlsx':
        case 'xls':
          return '<i class="fas fa-file-excel" style="color: #2e7d32;"></i>';
        default:
          return '<i class="fas fa-file" style="color: var(--green);"></i>';
      }
    }

    // Helper function to get file type display name
    function getFileTypeDisplay(fileType) {
      switch (fileType) {
        case 'pdf':
          return 'PDF';
        case 'xlsx':
          return 'Excel';
        default:
          return 'Document';
      }
    }

    // Toast notification function
    function showToast(message, type = "success") {
      const toast = document.getElementById("toast");
      const toastMessage = document.getElementById("toast-message");

      toast.className = "toast " + type;
      toastMessage.textContent = message;

      // Show toast
      toast.classList.add("show");

      // Hide after 3 seconds
      setTimeout(() => {
        toast.classList.remove("show");
      }, 3000);
    }

    function updateUI() {
      document.getElementById("auth").style.display = token ? "none" : "block";
      document.getElementById("pdf-management").style.display = token
        ? "block"
        : "none";

      if (token) {
        document.getElementById("user-info").style.display = "flex";
        document.getElementById("username").textContent =
          currentUsername || "User";
        fetchPDFs();
        fetchCollections();
        populateCollectionDropdown();
      } else {
        document.getElementById("user-info").style.display = "none";
      }
    }

    // File upload visual feedback
    const fileUpload = document.querySelector(".file-upload");
    const fileInput = fileUpload.querySelector('input[type="file"]');

    fileInput.addEventListener("change", function () {
      const fileInfo = fileUpload.querySelector(".file-info");

      if (this.files.length > 0) {
        const fileCount = this.files.length;
        const fileTypes = Array.from(this.files).map(file => {
          const ext = file.name.split('.').pop().toLowerCase();
          return ext === 'pdf' ? 'PDF' : ext === 'xlsx' || ext === 'xls' ? 'Excel' : 'File';
        });
        const uniqueTypes = [...new Set(fileTypes)];
        
        fileInfo.innerHTML = `
                    <h3>${fileCount} ${fileCount === 1 ? "file" : "files"} selected</h3>
                    <p>Types: ${uniqueTypes.join(', ')}</p>
                    <p><small>${Array.from(this.files).map(file => file.name).join(", ")}</small></p>
                `;
        fileUpload.style.borderColor = "var(--yellow)";
      } else {
        fileInfo.innerHTML = `
                    <h3>Drag & Drop your documents here</h3>
                    <p>or click to browse files</p>
                    <p><small>Supported formats: PDF, Excel (.xlsx, .xls)</small></p>
                `;
        fileUpload.style.borderColor = "var(--green)";
      }
    });

    // Register
    document
      .getElementById("register-form")
      .addEventListener("submit", async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);

        try {
          const response = await fetch("/register", {
            method: "POST",
            body: JSON.stringify({
              username: formData.get("username"),
              password: formData.get("password"),
            }),
            headers: { "Content-Type": "application/json" },
          });

          if (response.ok) {
            showToast("Registration successful. Please login.");
            e.target.reset();
          } else {
            const errorData = await response.json();
            showToast(errorData.detail || "Registration failed.", "error");
          }
        } catch (error) {
          showToast("Connection error. Please try again.", "error");
          console.error(error);
        }
      });

    // Login
    document.getElementById("login-form").addEventListener("submit", async (e) => {
      e.preventDefault();
      const formData = new FormData(e.target);

      try {
        const response = await fetch("/login", {
          method: "POST",
          body: new URLSearchParams({
            username: formData.get("username"),
            password: formData.get("password"),
          }),
        });

        if (response.ok) {
          const data = await response.json();
          token = data.access_token;
          currentUsername = formData.get("username");
          localStorage.setItem("token", token);
          localStorage.setItem("username", currentUsername);
          showToast("Login successful!");
          updateUI();
        } else {
          const errorData = await response.json();
          showToast(errorData.detail || "Login failed.", "error");
        }
      } catch (error) {
        showToast("Connection error. Please try again.", "error");
        console.error(error);
      }
    });

    // Logout
    document.getElementById("logout-btn").addEventListener("click", () => {
      localStorage.removeItem("token");
      localStorage.removeItem("username");
      token = null;
      currentUsername = null;
      showToast("Logged out successfully");
      updateUI();
    });

    // Upload Documents
    document.getElementById("upload-form").addEventListener("submit", async (e) => {
      e.preventDefault();
      const files = e.target.files.files;
      const description = e.target.description.value;
      const collection = document.getElementById("collection").value;

      if (files.length === 0) {
        showToast("Please select at least one file", "error");
        return;
      }

      // Validate file types
      const supportedTypes = ['pdf', 'xlsx', 'xls'];
      const invalidFiles = Array.from(files).filter(file => {
        const ext = file.name.split('.').pop().toLowerCase();
        return !supportedTypes.includes(ext);
      });

      if (invalidFiles.length > 0) {
        showToast(`Unsupported file types: ${invalidFiles.map(f => f.name).join(', ')}`, "error");
        return;
      }

      // Show loading state
      const submitBtn = e.target.querySelector('button[type="submit"]');
      const originalBtnText = submitBtn.innerHTML;
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
      submitBtn.disabled = true;

      const uploadedFileIds = [];
      let failedUploads = 0;

      for (const file of files) {
        const formData = new FormData();
        formData.append("file", file);
        formData.append("description", description || "");
        formData.append("collection", collection || "");

        try {
          const response = await fetch("/upload", {
            method: "POST",
            headers: { "Authorization": `Bearer ${token}` },
            body: formData,
          });

          if (response.ok) {
            const data = await response.json();
            uploadedFileIds.push(data.pdf_id);
          } else {
            failedUploads++;
          }
        } catch (error) {
          failedUploads++;
          console.error(`Error uploading ${file.name}:`, error);
        }
      }

      // Reset form and file upload visual
      e.target.reset();
      const fileInfo = fileUpload.querySelector(".file-info");
      fileInfo.innerHTML = `
                <h3>Drag & Drop your documents here</h3>
                <p>or click to browse files</p>
                <p><small>Supported formats: PDF, Excel (.xlsx, .xls)</small></p>
            `;
      fileUpload.style.borderColor = "var(--green)";

      // Reset button state
      submitBtn.innerHTML = originalBtnText;
      submitBtn.disabled = false;

      if (uploadedFileIds.length > 0) {
        showToast(`Uploaded ${uploadedFileIds.length} files. Processing in background.`);
        // Add status monitoring for uploaded files
        monitorPdfProcessing(uploadedFileIds);
        // Refresh the list to show pending files
        fetchPDFs();
      }

      if (failedUploads > 0) {
        showToast(`${failedUploads} uploads failed`, "error");
      }
    });

    // Add function to monitor PDF processing status
    async function monitorPdfProcessing(pdfIds) {
      const checkStatus = async () => {
        let allCompleted = true;

        for (const pdfId of pdfIds) {
          try {
            const response = await fetch(`/pdfs/${pdfId}/status`, {
              headers: { "Authorization": `Bearer ${token}` },
            });

            if (response.ok) {
              const data = await response.json();
              if (data.status === "pending") {
                allCompleted = false;
              } else if (data.status === "error") {
                showToast(`Error processing PDF: ${data.error_message || "Unknown error"}`, "error");
              }
            }
          } catch (error) {
            console.error(`Error checking status for PDF ${pdfId}:`, error);
          }
        }

        if (allCompleted) {
          showToast("All PDFs processed successfully!");
          fetchPDFs();
          return;
        }

        // Check again after 3 seconds
        setTimeout(checkStatus, 3000);
      };

      // Start checking
      setTimeout(checkStatus, 3000);
    }

    // Format date
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
      });
    }

    // Add these variables for sorting state
    let currentSort = {
      column: "upload_date",
      direction: "desc",
    };

    // Add the sorting function
    function sortPDFs(column) {
      if (currentSort.column === column) {
        // Toggle direction if clicking the same column
        currentSort.direction = currentSort.direction === "asc" ? "desc" : "asc";
      } else {
        // Default to descending for new column
        currentSort.column = column;
        currentSort.direction = "desc";
      }

      // Update sort icon
      const sortIcon = document.querySelector(`th[onclick="sortPDFs('${column}')"] i`);
      sortIcon.className = `fas fa-sort-${currentSort.direction}`;

      fetchPDFs();
    }

    // Update the fetchPDFs function to include a selection checkbox
    async function fetchPDFs() {
      try {
        const collectionParam = currentCollection
          ? `&collection=${encodeURIComponent(currentCollection)}`
          : "";
        const response = await fetch(
          `/pdfs?limit=${itemsPerPage}&offset=${(currentPage - 1) * itemsPerPage}${collectionParam}`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        if (!response.ok) {
          throw new Error("Failed to fetch documents");
        }

        const data = await response.json();
        const files = data.pdfs;
        const totalCount = data.total_count;
        const list = document.getElementById("pdf-list");
        const emptyState = document.getElementById("empty-state");
        const tableContainer = document.getElementById("pdf-table-container");

        list.innerHTML = "";

        if (files.length === 0) {
          emptyState.style.display = "block";
          emptyState.querySelector("h3").textContent = currentCollection
            ? `No documents in collection "${currentCollection}"`
            : "No documents found";
          emptyState.querySelector("p").textContent = currentCollection
            ? "Upload documents to this collection"
            : "Upload your first document to get started";
          tableContainer.style.display = "none";
          return;
        }

        emptyState.style.display = "none";
        tableContainer.style.display = "block";

        files.forEach((file, index) => {
          const tr = document.createElement("tr");
          tr.style.animationDelay = `${index * 0.05}s`;
          tr.classList.add("animate-fade-in");

          const collectionBadge = file.collection
            ? `<span class="badge" style="background-color: var(--dark-green);">
                             <i class="fas fa-layer-group"></i> ${file.collection}
                           </span>`
            : `<span class="badge" style="background-color: var(--gray); color: var(--black);">
                             <i class="fas fa-layer-group"></i> Default Collection
                           </span>`;

          // Add status indicator
          const statusBadge =
            file.status === "pending"
              ? `<span class="badge" style="background-color: orange;">
                             <i class="fas fa-spinner fa-spin"></i> Processing
                           </span>`
              : file.status === "error"
              ? `<span class="badge" style="background-color: #f44336;">
                                 <i class="fas fa-exclamation-circle"></i> Error
                               </span>`
              : `<span class="badge" style="background-color: var(--green);">
                                 <i class="fas fa-check"></i> Processed
                               </span>`;

          // Add file type badge
          const fileTypeDisplay = getFileTypeDisplay(file.file_type);
          const fileTypeBadge = `<span class="badge" style="background-color: var(--yellow); color: var(--black);">
                                     <i class="fas fa-tag"></i> ${fileTypeDisplay}
                                   </span>`;

          tr.innerHTML = `
                        <td>
                          <input type="checkbox" class="pdf-select" value="${file.id}" />
                        </td>
                        <td>
                          <div style="display: flex; align-items: center; gap: 10px;">
                              ${getFileIcon(file.filename, file.file_type)}
                              ${file.filename}
                              ${statusBadge}
                              ${fileTypeBadge}
                              ${collectionBadge}
                          </div>
                        </td>
                        <td>${file.description || "<em>No description</em>"}</td>
                        <td>${formatDate(file.upload_date)}</td>
                        <td>${file.pages_indexed} / ${file.pages_total}</td>
                        <td class="actions">
                            <button onclick="viewPDF(${file.id})" class="btn btn-view" ${file.status !== "processed" ? "disabled" : ""}>
                                <i class="fas fa-eye"></i> View
                            </button>
                            <button onclick="updatePDF(${file.id})" class="btn btn-update">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button onclick="deletePDF(${file.id})" class="btn btn-delete">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </td>
                    `;
          list.appendChild(tr);
        });

        // Add pagination controls
        const paginationControls = document.getElementById("pagination-controls");
        if (paginationControls) {
          paginationControls.innerHTML = "";
        }
        const totalPages = Math.ceil(totalCount / itemsPerPage);
        const startItem = (currentPage - 1) * itemsPerPage + 1;
        const endItem = Math.min(currentPage * itemsPerPage, totalCount);

        // Display current range
        const rangeInfo = document.createElement("div");
        rangeInfo.textContent = `Showing ${startItem} to ${endItem} of ${totalCount} documents.`;
        rangeInfo.style.marginBottom = "10px";
        if (paginationControls) {
          paginationControls.appendChild(rangeInfo);
        }

        // Previous button
        const prevButton = document.createElement("button");
        prevButton.textContent = "«";
        prevButton.className = "btn";
        prevButton.disabled = currentPage === 1;
        prevButton.addEventListener("click", () => {
          currentPage--;
          fetchPDFs();
        });
        if (paginationControls) {
          paginationControls.appendChild(prevButton);
        }

        // Page buttons
        for (let i = 1; i <= totalPages; i++) {
          const pageButton = document.createElement("button");
          pageButton.textContent = i;
          pageButton.className = "btn";
          if (i === currentPage) {
            pageButton.disabled = true;
          }
          pageButton.addEventListener("click", () => {
            currentPage = i;
            fetchPDFs();
          });
          if (paginationControls) {
            paginationControls.appendChild(pageButton);
          }
        }

        // Next button
        const nextButton = document.createElement("button");
        nextButton.textContent = "»";
        nextButton.className = "btn";
        nextButton.disabled = currentPage === totalPages;
        nextButton.addEventListener("click", () => {
          currentPage++;
          fetchPDFs();
        });
        if (paginationControls) {
          paginationControls.appendChild(nextButton);
        }
      } catch (error) {
        showToast("Failed to load documents", "error");
        console.error(error);
      }
    }

    // Add pagination controls container
    document.addEventListener("DOMContentLoaded", () => {
      const tableContainer = document.getElementById("pdf-table-container");
      const paginationControls = document.createElement("div");
      paginationControls.id = "pagination-controls";
      paginationControls.style.marginTop = "20px";
      paginationControls.style.textAlign = "center";
      tableContainer.parentNode.insertBefore(paginationControls, tableContainer.nextSibling);
    });

    // View PDF
    function viewPDF(pdfId) {
      window.open(`/pdfs/${pdfId}/view`, "_blank");
    }

    // Update PDF
    async function updatePDF(pdfId) {
      const description = prompt("Enter new description:");
      if (description !== null) {
        try {
          const response = await fetch(`/pdfs/${pdfId}`, {
            method: "PUT",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ description: description }),
          });

          if (response.ok) {
            showToast("PDF updated successfully");
            fetchPDFs();
          } else {
            const error = await response.json();
            showToast("Update failed: " + (error.detail || "Unknown error"), "error");
          }
        } catch (error) {
          showToast("Connection error. Please try again.", "error");
          console.error(error);
        }
      }
    }

    // Delete PDF
    async function deletePDF(pdfId) {
      if (confirm("Are you sure you want to delete this PDF?")) {
        try {
          const response = await fetch(`/pdfs/${pdfId}`, {
            method: "DELETE",
            headers: { Authorization: `Bearer ${token}` },
          });

          if (response.ok) {
            showToast("PDF deleted successfully");
            fetchPDFs();
          } else {
            showToast("Delete failed", "error");
          }
        } catch (error) {
          showToast("Connection error. Please try again.", "error");
          console.error(error);
        }
      }
    }

    // Toggle select all checkboxes
    function toggleSelectAll(source) {
      const checkboxes = document.querySelectorAll(".pdf-select");
      checkboxes.forEach((cb) => (cb.checked = source.checked));
    }

    // Get selected PDF IDs
    function getSelectedPDFs() {
      const selected = [];
      document.querySelectorAll(".pdf-select:checked").forEach((cb) => {
        selected.push(cb.value);
      });
      return selected;
    }

    // Bulk delete selected PDFs
    async function bulkDeletePDFs() {
      const selectedIds = getSelectedPDFs();
      if (selectedIds.length === 0) {
        showToast("No PDFs selected", "error");
        return;
      }
      if (!confirm("Are you sure you want to delete the selected PDFs?")) return;

      for (const id of selectedIds) {
        try {
          const response = await fetch(`/pdfs/${id}`, {
            method: "DELETE",
            headers: { Authorization: `Bearer ${token}` },
          });
          if (!response.ok) {
            showToast(`Failed to delete PDF ${id}`, "error");
          }
        } catch (error) {
          showToast(`Connection error while deleting PDF ${id}`, "error");
        }
      }
      showToast("Selected PDFs deleted successfully");
      fetchPDFs();
    }

    // Bulk update description for selected PDFs
    async function bulkUpdatePDFsDescription() {
      const selectedIds = getSelectedPDFs();
      if (selectedIds.length === 0) {
        showToast("No PDFs selected", "error");
        return;
      }
      const description = prompt("Enter new description for selected PDFs:");
      if (description === null) return;

      for (const id of selectedIds) {
        try {
          const response = await fetch(`/pdfs/${id}`, {
            method: "PUT",
            headers: {
              Authorization: `Bearer ${token}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ description: description }),
          });
          if (!response.ok) {
            showToast(`Failed to update PDF ${id}`, "error");
          }
        } catch (error) {
          showToast(`Connection error while updating PDF ${id}`, "error");
        }
      }
      showToast("Selected PDFs updated successfully");
      fetchPDFs();
    }

    // Collection Management Functions
    async function createCollection() {
      const name = document.getElementById("collection-name").value;
      const description = document.getElementById("collection-description").value;

      if (!name) {
        showToast("Please enter a collection name", "error");
        return;
      }

      try {
        const response = await fetch("/collections", {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ name, description }),
        });

        if (response.ok) {
          showToast("Collection created successfully");
          fetchCollections();
          document.getElementById("collection-name").value = "";
          document.getElementById("collection-description").value = "";
        } else {
          const error = await response.json();
          showToast(error.detail || "Failed to create collection", "error");
        }
      } catch (error) {
        showToast("Connection error", "error");
      }
    }

    async function fetchCollections() {
      try {
        const response = await fetch("/collections", {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (response.ok) {
          collections = await response.json();
          const listElement = document.getElementById("collections-list");

          if (collections.length === 0) {
            listElement.innerHTML = `
                            <div class="empty-state">
                                <i class="fas fa-layer-group"></i>
                                <h3>No collections yet</h3>
                                <p>Create your first collection to get started</p>
                            </div>
                        `;
            return;
          }

          listElement.innerHTML = `
                        <table>
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Documents</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${collections
                                  .map(
                                    (collection) => `
                                    <tr>
                                        <td>${collection.name}</td>
                                        <td>${collection.vectors_count}</td>
                                        <td class="actions">
                                            <button onclick="deleteCollection('${collection.name}')" class="btn btn-delete">
                                                <i class="fas fa-trash"></i> Delete
                                            </button>
                                        </td>
                                    </tr>
                                `
                                  )
                                  .join("")}
                            </tbody>
                        </table>
                    `;
        }
      } catch (error) {
        showToast("Failed to fetch collections", "error");
      }
    }

    async function deleteCollection(name) {
      if (!confirm(`Are you sure you want to delete collection "${name}"?`)) {
        return;
      }

      try {
        const response = await fetch(`/collections/${name}`, {
          method: "DELETE",
          headers: { Authorization: `Bearer ${token}` },
        });

        if (response.ok) {
          showToast("Collection deleted successfully");
          fetchCollections();
        } else {
          showToast("Failed to delete collection", "error");
        }
      } catch (error) {
        showToast("Connection error", "error");
      }
    }

    // Populate collection dropdowns for upload and filtering
    async function populateCollectionDropdown() {
      try {
        const response = await fetch("/collections", {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (response.ok) {
          const collectionsData = await response.json();
          
          // Prepare options data for searchable dropdowns
          const uploadOptions = collectionsData.map(collection => ({
            value: collection.name,
            text: collection.name
          }));
          
          const filterOptions = [
            { value: 'default', text: 'Default Collection' },
            ...collectionsData.map(collection => ({
              value: collection.name,
              text: collection.name
            }))
          ];

          // Update searchable dropdowns if they exist
          if (collectionDropdown) {
            collectionDropdown.updateOptions(uploadOptions);
          }
          
          if (collectionFilterDropdown) {
            collectionFilterDropdown.updateOptions(filterOptions);
          }
        }
      } catch (error) {
        console.error("Failed to fetch collections:", error);
      }
    }

    // Filter by collection is now handled by the searchable dropdown callback

    // Initial UI update
    updateUI();
  </script>
</body>
</html>